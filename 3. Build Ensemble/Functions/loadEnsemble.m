function[M] = loadEnsemble(file, nEns, index)
%% Loads an ensemble from a .ens file.
%
% M = loadEnsemble( file )
% Load the entire ensemble from a .ens file.
%
% M = loadEnsemble( file, nEns )
% Loads the the first nEns ensemble members from the .ens file.
%
% M = loadEnsemble( file, nEns, index )
% Loads nEns ensemble members from the specified indices.
%
% ----- Inputs -----
%
% file: A .ens file generated by "buildEnsemble.m"
%
% nEns: The number of ensemble members to load from the file.
%
% index: The indices of specific ensemble members to load. If evenly
%        spaced, the ensemble is obtained via partial loading (faster). If
%        unevenly spaced, the ensemble members are loaded iteratively (slower).
%
% ----- Outputs -----
%
% M: A prior model ensemble

% ----- Written By -----
% Jonathan King, University of Arizona, 2019

% Check that the file is valid. Get a matfile object.
m = ensFileCheck(file, 'load');
nTot = m.ensSize(1,2);

% Error check nEns
if exist('nEns','var')
    if ~isscalar(nEns) || nEns < 1 || mod(nEns,1)~=0
        error('nEns must be a scalar, positive integer.');
    elseif nEns > nTot
        error('nEns is larger than the total number of ensemble members (%.f).', nTot );
    end
    
% If unspecified, load the entire ensemble
else
    nEns = m.ensSize(1,2);
end

% If indexing to specific values
if exist('index','var')
    
    % Check the indices. Convert to linear if logical
    index = errCheckIndex( index, nEns, m.ensSize(2) );
    
    % Sort the indices to check spacing. Also get the reverse sorting indices
    [sorted, iA] = sort(index);
    
    % If equally spaced
    if numel(sorted)==1 || numel(unique(diff(sorted)))==1
        
        % Load the ensemble
        M = m.M(:,sorted);
        
        % Get the indices to perform a reverse sort (to match the original
        % index order)
        index = 1:numel(index);
        unsort = iA(index);
        
        % Reverse sort the ensemble members
        M = M(:, unsort);
    
    % But if not equally spaced, going to load iteratively
    else
        
        % Preallocate the final ensemble
        M = NaN( m.ensSize(1), nEns );
        
        % Load each ensemble member
        for k = 1:nEns
            M(:,k) = m.M(:, index(k) );
        end
    end
    
% If not indexing, just load the first nEns ensemble members.
else
    M = m.M(:, 1:nEns);
end

end

function[index] = errCheckIndex( index, nEns, nTot )

% If logical indices
if islogical( index )

    % Check they match the size of the ensemble
    if ~isvector(index) || length(index)~=nTot
        error('Logical indices must be a vector the length of the ensemble size (%.f).', nTot );

    % If so, convert to linear indices
    else
        index = find(index);
    end
end

% Error check the indices
if ~isvector(index) || ~isnumeric(index) || any(index<1) || any( mod(index,1)~=0 )
    error('Indices must be a vector of positive integers.');
elseif max(index) > nTot
    error('Some of the indices (%.f) are larger than the ensemble size (%.f).', max(index), nTot );
elseif numel(unique(index)) ~= numel(index)
    error('The set of indices cannot contain duplicate elements.');
end

% Check it matches nEns
if length(index) ~= nEns
    error('The number of indices (%.f) does not match nEns (%.f).', length(index), nEns );
end

end